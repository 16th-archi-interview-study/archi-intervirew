# 증권 거래소
## 문제 이해 및 설계 범위
- 현대 증권 거래소에 따라 지연 시간, 처리량, 안정성에 대한 엄격한 요구
- 주식에 대한 새로운 주문, 주문 취소, 지정가 주문을 메인으로 한다.
- 호가 창에 대한 실시간 갱신이 필요하다. (매수 및 매도 주문 목록 표시)
- 규칙을 위반한 거래가 생기지 않도록 위험성 점검 기능 필요


또한 반드시 지켜야하는 특징들이 있다.


1. 가용성: 단 몇 초의 장애로도 평판이 손상될 수 있어서 가용성은 매우 중요한 문제
2. 결함 내성: 실시간 장애의 파급 효과를 줄이기 위해서는 결함 내성과 빠른 복구 메커니즘 필요
3. 지연 시간: ms 수준의 왕복 지연시간 지원 필요 (특히, p99 지연 시간 지키는 것이 중요)
4. 보안: 거래소의 계정 관리 시스템, 법률 및 규정 준수, 신원 확인, 데이터 유출 방어 등


---
## 개략적 설계안
아래 다이어그램에는 중요 경로인 거래 흐름, 시장 데이터 흐름, 보고 흐름이 한 번에 나와있다.



### 거래 흐름 (Critical Path)
하나의 주문이 어떤 절차로 처리되는지 거래 흐름을 보면 알 수 있다. 지연 시간 요건이 엄격한 중요 경로라고 할 수 있다.


<img src="/2_chapter-13/img/arch_v1.png" alt="arch-v1" width="80%">


- 1단계: 고객이 브로커의 웹 or 모바일 앱을 통해 주문
- 2단계: 브로커가 주문을 거래소에 전송
- 3단계: 주문이 클라이언트 게이트웨이를 통해 거래소로 들어감
- 4~5단계: 주문 관리자가 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행
- 6단계: 위험성 점검 과정을 통과한 주문에 대해, 주문 관리자가 지갑에 주문 처리 자금이 충분한지 확인
- 7~9단계: 주문이 체결 엔진으로 전송 + 체결 엔진은 체결 가능 주문을 매수 측과 매도 측에 각각 두 개의 집행 기록 생성(execution)
    - 시퀀서는 주문 및 집행 기록을 일정 순서로 정렬한다.
- 10~14단계: 주문 집행 사실을 클라이언트에게 전송


### 시장 데이터 흐름 (Market Data Flow)
하나의 주문이 체결 엔진부터 데이터 서비스를 거쳐 브로커로 전달되어 집행되기까지의 과정을 추적할 수 있다.


<img src="/2_chapter-13/img/arch_v2.png" alt="arch-v2" width="80%">


- M1 단계: 체결 엔진은 주문이 체결되면 집행 기록 스트림을 만든다. (이 스트림은 시장 데이터 게시 서비스로 전송)
- M2 단계: 시장 데이터 게시 서비스는 집행 기록 및 주문 스트림에서 얻은 데이터로 봉 차트와 호가 창을 구성한다.
- M3 단계: 시장 데이터는 실시간 분석 전용 스토리지에 저장되고, 브로커는 이 시장 데이터를 고객에게 전달한다.


### 보고 흐름 (Reporting Flow)


<img src="/2_chapter-13/img/arch_v3.png" alt="arch-v3" width="80%">


- R1~R2 단계: 보고 서비스(reporter)는 주문 및 실행 기록에서 보고에 필요한 모든 필드의 값을 모은 후, 그 값을 종합해서 만든 레코드를 DB에 기록한다.


지연 시간을 줄여야하는 중요 경로와 달리, 시장 데이터 흐름과 보고 흐름은 지연 시간 요구사항이 좀 더 넉넉함을 염두에 두고 설계하면 좋다.


---
## 상세 설계
### 성능
지연 시간은 거래소에 아주 중요한 문제이다. 평균 지연 시간은 낮게, 전반적인 지연 시간 분포는 안정적이도록 관리해야 한다.
이를 관찰하기 위한 좋은 척도는 p99 지표이다.


지연 시간을 줄이기 위한 두 가지 방법이 있다.


1. 중요 경로에서 실행할 작업 수를 줄인다.
2. 각 작업의 소요 시간을 줄인다.
    - 네트워크 및 디스크 사용량 경감
    - 각 작업의 실행 시간 경감


따라서, 중요 경로에는 꼭 필요한 구성 요소만 두고(게이트웨이, 주문 관리자, 시퀀서, 체결 엔진), 로깅도 지연 시간을 줄이기 위해 뺀다.



### 단일 서버로 네트워크 지연 시간 줄이기
- 거래소는 속도를 위해 네트워크와 디스크 액세스 지연 시간을 줄이고자 했다. 
- 핵심 경로 중간에 네트워크를 통해 통신하는 컴포넌트가 많을 수록 총 네트워크 지연 시간이 늘어난다.


따라서, 모든 것을 동일한 서버에 배치하여 네트워크를 통하는 구간을 없애고, 같은 서버 내 컴포넌트 간 통신을 이벤트 저장소 mmap을 통해서 실행한다.



<img src="/2_chapter-13/img/monolith.png" alt="monolith" width="80%">


1. mmap: “메모리 매핑(memory-mapped I/O)”을 위한 운영체제(주로 Unix/Linux)의 시스템 호출을 말한다.
    - 파일(또는 디바이스)을 프로세스의 가상 메모리 공간에 그대로 mapping해서, 파일을 읽고 쓰는 작업을 일반적인 `read()` / `write()` 대신 메모리에 접근하듯이 하도록 만들어준다.
    - 기존 `read()` / `write()`는 매번 커널 호출이 필요하지만, mmap은 한 번 mapping 후 메모리 접근만으로 I/O가 가능하기 때문에 시스템 콜 호출이 감소하고 지연 시간이 절감 된다.
    - mmap으로 이벤트 로그 파일을 메모리에 바로 mapping 하여 별도 네트워크/IPC 채널을 거치지 않고 같은 프로세스(서버) 내에서 즉시 접근하고, 필요시 커널이 알아서 페이지를 디스크에 반영하기 때문에 영속성도 확보된다.


2. 애플리케이션 루프: 애플리케이션 루프의 주된 작업 실행 메커니즘은 `while` 순환문을 돌면서 본인의 실행 작업을 계속 polling 하는 것이다.
    - 엄격한 시간 요건을 만족하기 위해 가장 중요한 작업만 순환문 안에서 처리한다.
    - CPU 효율성을 위해 단일 스레드로 구현하며, 특정 CPU 코어에 고정시켜 context switching이나 경합 없이 온전히 main 작업에만 할당한다.



### 이벤트 소싱
현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한(immutable) 로그를 유지하는 방식. 해당 로그를 모든 진실의 원천으로 삼는 방식이다.


이벤트 소싱 아키텍처를 사용하면, 모든 이벤트를 추적하므로, 추적한 이벤트를 순서대로 재생하기만 하면 주문 상태를 복구할 수 있다는 장점이 있다.

이는 카프카와 상당히 유사한데, 지연 시간에 대한 엄격한 요구사항만 없다면 카프카를 사용할 수도 있는 구조이다. 그러나 지연 시간을 지키기 위해 mmap 이벤트 저장소를 사용한다.




---
### 고가용성
서비스가 다운되면 즉각 복구되도록 만들어야한다.


1. 거래소 아키텍처의 SPOF를 식별하여, 주 인스턴스를 다중화해야 한다.
2. 장애 감지 및 백업 인스턴스로의 장애 조치 결정이 빨라야한다.
    - 특히, 주문 관리자나 체결 엔진처럼 상태를 저장하는 컴포넌트는 사본 간 상태를 복사할 수 있어야 한다.
    - ex. 부 체결 엔진은 main과 동일한 이벤트를 수신하고 처리하지면 이벤트 저장소로 이벤트를 전송하지 않게 만들고, main이 다운되면 main의 지위를 승계한다.


---
### 결함 내성
결함 내성이 있는 시스템을 만들고자 생각해야 하는 문제들은 다음과 같다.


1. 주 서버가 다운되면 언제, 어떻게 부 서버로 자동 전환하는 결정을 내릴건지?
2. 부 서버 가운데 새로운 리더는 어떻게 선출하는지?
3. 복구 시간 목표 (Recovery Time Objective, RTO)는 얼마인가?
4. 어떤 기능을 복구해야 하는가? (Recovery Point Objective, RPO)


이런 문제들은 실전에서 검증된 리더 선출 알고리즘에 따라 해결할 수 있다. 책에서는 대표적인 예시로 Raft 알고리즘을 소개하고 있다.


### Raft
- 분산 시스템 환경에서 모든 노드가 동일한 상태를 유지하도록 하고, 일부 노드에 결함이 생기더라도 전체 시스템이 문제 없이 동작하도록 만들기 위해 고안된 합의 알고리즘(Consensus Algorithm)의 일종

- 적용된 분산 시스템에서 모든 노드는 아래의 세 가지 중 하나의 상태를 가진다.

    1. 리더(Leader) : 클러스터를 대표하는 하나의 노드다. 리더는 클라이언트가 클러스터로 보낸 모든 명령의 수신 및 전파, 그리고 응답을 전담한다. 또한 리더는 자신의 상태 메시지(heartbeat)를 주기적으로 모든 팔로워에게 전파한다.
    2. 팔로워(Follower) : 리더가 존재하는 한 나머지 노드는 이 상태를 유지한다. 리더로부터 전파된 명령을 처리하는 역할만 담당한다.
    3. 후보자(Candidate) : 리더가 없는 상황에서 새 리더를 정하기 위해 전환된 팔로워의 상태를 의미한다. 리더로부터 일정 시간 이상 상태 메시지(heartbeat)를 받지 못한 팔로워는 후보자로 전환된다.

- 위와 같은 flow로 후보자는 다른 나머지 팔로워에게 투표를 요청하여 과반수 이상의 표를 받았을 때 새로운 리더로 선출된다.



---
ref.
- [Stock-Exchange-System-Design](https://github.com/ByteByteGoHq/system-design-101/blob/main/data/guides/design-stock-exchange.md)
- [Raft-Consensus](https://seongjin.me/raft-consensus-algorithm/)