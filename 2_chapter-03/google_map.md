# 구글 맵 설계
- 구글 맵은 약 10억 DAU를 가진다.
- 핵심 기능은 위치 갱신, 경로 안내, ETA(Estimated Time of Arrival), 지도 표시에 초점을 맞춘다.
- 도로 데이터와 교통 상황을 고려한다.
- 운전, 대중교통, 걷기 등 다양한 이동 방법을 지원해야 한다.


---
## 기능 요구사항
- 지원할 주 단말은 모바일으로 한다.
- 사용자 위치 갱신 기능
- 경로 안내 서비스(ETA 포함)
- 지도 표시


## 비기능 요구사항 및 제약사항
- 정확도
- 부드러운 경로 표시
- 데이터 및 배터리 사용량 최적화
- 일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항 만족


---
## 구글 맵 설계에 필요한 사전 지식
### 측위 시스템
- 지구는 축을 중심으로 회전하는 구와 유사한 형태이다.
- 측위 시스템은 구 표현 상의 위치를 표현하는 체계를 말한다.
- 위경도를 사용하여 나타낸다.


### 3차원 위치의 2차원 변환
- 3차원 구 위의 특정 위치를 2차원 평면에 대응시키는 절차를 "지도 투영법" or "도법"이라고 한다.
- 다양한 도법이 있는데, 3차원을 2차원으로 표현하기 위해서는 필연적으로 실제 지형의 기하학적 특성이나 넓이 등이 왜곡될 수 있다.
- 구글 맵은 메르카토르 도법을 조금 변경한 웹 메르카토르 도법을 선택한다.


### 지오코딩
- 지오코딩은 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스이다.
- 특정 주소를 지오코딩을 통해 위경도 좌표로 변경하는 것이다.
- 인터폴레이션을 통해 GIS(Geographic Infromation System) 등의 시스템이 제공하는 데이터를 결합해서 수행한다.


### 지오해싱
- 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계이다.
- 지도해싱은 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해나간다.
- 어떤 격자를 재귀적으로 분할한 결과로 나온 더 작은 격자에는 0~3까지의 번호를 부여한다.


### 지도 표시(화면 렌더링)
- 지도를 화면에 표시할 때, 가장 기본이 되는 개념은 타일이다.
- 지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개서 표시한다.
- 클라이언트는 사용자가 원하는 영역에 관계된 타일만 다운받아, 이어붙여서 화면에 뿌린다.
- 지도의 확대/축소를 지원하기 위해 지도 확대 수준(zoom-level)에 따라 다른 크기의 타일을 가져온다.


### 경로 안내 알고리즘을 위한 도로 데이터 처리(전처리)
- 보통 경로 탐색 알고리즘은 Dijkstra 알고리즘이나 A* 알고리즘의 변종을 사용한다.
- 도로 데이터 처리에서의 그래프 구조 전처리
    - Node: 교차로를 노드로 가정한다.
    - Edge: 도로를 노드를 잇는 엣지로 가정한다.
- 대부분의 경로 탐색 알고리즘의 성능은 주어진 그래프 크기에 민감하기 때문에 그래프를 관리 가능 단위로 분할할 필요가 있다.
    - 이건 사실 Node랑 Edge 수 가지고 경로 탐색 알고리즘 시간 복잡도를 생각해보면 알 수 있다.
    - 먼 거리일수록 좀 더 추상화된 도로 체계를 제공하면 Graph에 포함되는 Node와 Edge 수를 효과적으로 줄일 수 있다.


### 경로 안내 타일
- 격자 안에 Node와 Edge로 구성된 그래프 자료 구조를 말한다.
- 각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지한다. 
- 도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 
    - 경로 탐색 알고리즘이 동작하는 데 필요한 메모리 요구량을 낮출 수 있고
    - 한 번에 처리해야 하는 경로 양이 줄어들고
    - 필요한 만큼 불러오기 때문에 경로 탐색 성능이 좋아진다.


### 계층적 경로 안내 타일
- 이전에 언급했던, 효과적인 동작을 위해 필요한 수준의 구체성을 갖춘 도로 데이터가 필요하다.
- 보통 필요한 구체성의 정도를 Level로 구분하여(상, 중, 하) 세 가지 종류의 경로 안내 타일을 준비한다.
    - 상: 타일의 크기가 매우 작으며, 작은 도로들까지 포함
    - 중: 더 넓은 지역 커버, 규모가 비교적 큰 관할구를 잇는 간선 도로 데이터만 포함
    - 하: 매우 큰 영역 커버, 도시와 주를 연결하는 주요 고속도로 데이터만 포함


---
## 개략적 규모 추정
### 저장소 사용량
아래와 같이 세 가지 종류의 데이터를 저장한다.

1. 세계 지도
    - 확대수준 별로 지도 타일을 하나씩 두어야 한다.
    - 타일 전부를 보관하는데 필요한 용량을 가늠하려면, 최대로 확대하여 볼 때 필요한 타일 개수를 따져보자.
    - 세계 지도를 21번 확대하여 볼 수 잇으려면 4.4조개의 타일이 필요하다.
    - 한 장의 타일이 256 * 256 픽셀이라면, 한 장당 100kb 저장공간이 필요하다.
    - 단순 계산 상으로, 440PB(4.4조 * 100KB) 정도의 공간이 필요하다.
    - 사람이 살지 않는 자연 타일은 최대한 압축하여 보관할 수 있다. (지구 표면 가운데에 90%가 자연)
    - 따라서, 44~88PB 정도의 용량이 필요하고, 확대 수준이 떨어질 때마다 추가되는 타일까지 어림잡으면 100PB 정도이다. 

2. 메타 데이터: 각 지도 타일의 메타 데이터는 크기가 아주 작기 때문에 무시 가능
3. 도로 정보: 외부에서 받은 수 TB 용량의 도로 데이터를 보유


### 서버 대역폭
구글 맵 서버가 처리해야 하는 요청은 크게 두 가지이다.


1. 경로 안내 요청: 클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지
2. 위치 갱신 요청: 클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지


경로 안내 요청을 처리하기 위한 서버 대역폭을 분석하면 아래와 같다.

- DAU: 10억
- 사용 시간: 주당 35분, 하루 기준 계산하면 (35분 * 10억명) / 7 = 50억분
- 하루 3000억 건 요청(50억 * 60)  = 약 3백만 QPS


하지만, 클라이언트가 매초 새로운 GPS 좌표를 보낼 필요가 없을 수도 있다. GPS 위치 변경 내역을 모아두었다가 15초마다 한 번씩 서버로 보내도록 가정하면 QPS가 줄어든다.


---
## 개략적 설계 제시
아래 개략적 설계안은 세 가지 기능을 제공한다.


1. 위치 서비스 (Location Service)
2. 경로 안내 서비스 (Navigation Service)
3. 지도 표시 (Map Rendering)


<img src="/2_chapter-03/img/arch-v1.png" alt="arch-v1" width="60%">


### 1. 위치 서비스
- 클라이언트가 t초마다 자기 위치를 전송한다고 가정 (여기서 t는 설정이 가능한 값)
    - 위치 변경 내역을 클라이언트에 버퍼링해 두었다가 일괄 요청(batch request) 하여 전송 빈도 줄이기
- 클라이언트가 보내는 정보로 실시간 교통 상황을 모니터링하거나 ETA를 정확히 산출하는데 쓸 수 있다.
- 사용자가 많아 쓰기 요청이 많다.
    - 높은 쓰기 요청에 최적화되어 있고 규모 확장이 용이한 Cassandra 같은 DB 필요
    - Kafka 같이 Stream 엔진을 활용하여 위치 데이터 로깅할 수 있음
- 통신 프로토콜으로는 HTTP 1.1 이상의 Keep-alive 옵션이 효율적일 것이다. (연결 유지)


### 2. 경로 안내 서비스
- 합리적으로 빠른 경로 제시 (반드시 최단 시간 경로일 필요는 없으나, 정확도는 보장되어야 함)
- 결과를 얻는데 드는 시간 지연 있음
- 경로 재탐색이나 교통 상황 변화 반영 등은 적응형 ETA를 통해 해결할 수 있다.


### 3. 지도 표시
- 전체 타일 용량이 매우 크므로, 클라이언트가 필요한 타일을 서버에서 가져오는게 좋다.
- 확대 수준 별로 미리 만들어 둔 지도 타일을 클라이언트에 전달한다. (CDN을 통해 serving)
- 클라이언트가 가져올 지도 타일에 대한 값을 계산하여(위경도 좌표, 현재 지도 확대 수준 등) 타일을 요청한다.


---
## 상세 설계
### 위치 서비스
- 초당 백만 건 이상의 위치 정보 업데이트 발생
- 쓰기 연산 지원에 탁월한 NoSQL + CAP 이론에서 AP를 만족하도록 (어차피 위치는 계속 갱신되어서 일관성 무의미함)
- DB Key (`user_id`: 파티션 키, `timestamp`: 클러스터링 키)
    - 같은 파티션 키를 가지면 같은 샤드에 저장, 클러스티링 키 값에 따라 정렬



### 사용자 위치 데이터 이용


<img src="/2_chapter-03/img/location_data_service.png" alt="location_service" width="70%">


- 사용자 위치는 쓰임새가 다양한 중요 데이터이기 때문에, 설계자의 관점에서 해당 정보를 어떻게 유용하게 다룰지 고민해야 한다.
- 위 다이어그램과 같이, 다양한 용례를 지원하기 위해 Kafka 같은 MQ에 로깅한다.
    - 응답 지연이 낮고 많은 데이터를 처리할 수 있는 데이터 스트리밍 플랫폼이기 때문에 선택
- 개별 서비스들이 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 활용한다.


### 지도 표시
- 확대 수준별로 타일 크기, 해상도 등이 달라질 수 있다.
- 최적화를 위해 WebGL 기술을 채택하여 이미지 전송 대신 path, polygon, vector 등의 정보를 보낼 수 있다.
- 클라이언트는 수신된 경로와 다각형 정보를 통해 지도를 그려낼 수 있다.
- vector 타일은 이미지에 비해 월등한 압축률을 갖기 때문에 네트워크 대역폭을 효과적으로 아낄 수 있다.


### 경로 안내 서비스
- 이 서비스는 가장 빠른 경로를 안내하는 역할을 담당한다.


<img src="/2_chapter-03/img/path_planning_service.png" alt="path_service" width="70%">


- 최단 경로 서비스: A* 알고리즘의 한 형태를 실행하여 출발지~목적지까지의 k개의 최단 경로를 반환한다.
- 예상 도착 시간 서비스(ETA): 최단 경로 목록을 수신한 뒤 소요 시간 추정치를 구한다. (기계 학습에 현재 교통 상황, 과거 이력 등 활용)
- 순위 결정 서비스: ETA 예상치를 구한 후, 사용자가 정의한 필터링 조건이나 특수 필터링을 적용한다.
    - ex. 유료 도로 제외, 고속도로 제외 등


이러한 서비스들은 카프카 위치 데이터 스트림을 구독하고 있다가, 중요 데이터를 비동기적으로 업데이터하여 상태를 최신으로 유지하려고 한다. (ex. 실시간 교통 정보 DB나 경로 안내 타일에서 도로 정보 update)



### 재귀적인 경로 타일


<img src="/2_chapter-03/img/recursive_path_tile.png" alt="recursive_path_tile" width="40%">


만약, 유저가 안내받은 경로 타일을 단순 List로 들고 있다고 가정하자.


- 유저 N명마다 M개의 타일을 List로 가지고 있을 때, 하나의 타일이 변경되면 O(N*M) 만큼의 탐색 시간이 걸린다. (비효율적)
- 유저 N명마다 본인의 타일을 재귀적으로 더하여 보관하면 검색 시간 복잡도를 O(N)으로 줄일 수 있다.
- 위 그림처럼, 유저마다 출발지와 도착지를 모두 포함한 타일을 재귀적으로 들고있다가, 해당 타일에서만 체크하면 된다.
    - 접두사 비교나 비트 마스킹 등으로 재귀적으로 더해진 타일에서 O(1) 수준의 연산


### 전송 프로토콜
- 경로 안내 중에 상황이 변경될 수 있으므로 이를 모바일 클라이언트에 안정적으로 전송해야 한다.
- 모바일 Push 알림은 메시지 크기 제한으로 때문에, 롱 폴링은 서버 부담이 크기 때문에 적합하지 않다.
- 웹소켓이나 SSE를 사용할 수 있으나, 웹소켓이 양방향 통신이 가능하므로 최종 설계에 채택하였다. 