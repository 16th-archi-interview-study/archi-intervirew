# 알림 시스템 설계
- 알림 시스템은 크게 세 가지로 분류할 수 있다.
- Mobile Push / SMS / E-mail


## 1. 문제 이해 및 설계 범위 확정
확장성 높은 알림 시스템 설계를 위해서는 어떤 요구사항을 만족해야 하는지 꼼꼼히 체크해야 한다.


- 어떤 종류의 알림을 지원해야 하는지? (Mobile / SMS / E-mail 등)
- 실시간 알림 시스템이어야 하는지?
- 어떤 종류의 디바이스를 지원해야 하는지? (iOS, Android, labtop, desktop 등)
- 사용자에게 보낼 알림을 만들 수 있는 권한이 누구에게 있는지?
- 사용자가 알림 수신에 대한 옵션을 직접 설정할 수 있는지 (수신 여부, 수신 종류 등)
- 하루 몇 건의 알림을 보내야 하는지? (대략적인 규모 추정)


## 2. 개략적 설계안 제시
### 알림 유형별 지원 방안
- iOS, Android, SMS 메시지, 이메일 등을 보낼 때 third-party 서비스들을 많이 사용한다.
- 여기서 iOS나 Android 같이 디바이스 종속적인 환경인 경우 알림 요청을 만들 때 device token 같은 고유 식별자가 추가로 필요하다.


![third_party_service](/chapter-10/img/third_party_service.png)



### 연락처 정보 수집 절차
- 알림을 보내기 위해서 필요한 정보들을 사전에 수집해야 한다. (앱 설치나 계정 등록 시)
    - 모바일 기기라면, 고유 Device Token
    - SMS에 필요한 전화번호
    - 이메일 주소 등
- DB에 연락처 정보를 저장할 때, 한 사람이 여러 기기에 대한 정보를 가질 수 있는 것을 고려해서 적절히 테이블을 설계해야 한다.


### 알림 전송 및 수신 절차
- 초기 설계는 여러 종류의 서비스들이 단일 알림 서버에 의존하는 형태로 생각할 수 있다.
- 그러나 이는 여러 문제점을 가질 수 있다.
    1. SPOF
    2. 규모 확장 어려움
    3. 성능 병목: 알림을 처리하고 보낼 때 자원을 소모하는 경우가 많은데, 조금이라도 트래픽이 몰리면 과부하 가능성이 높아진다.


이런 문제점을 개선하는 방향으로, 다음과 같은 방법이 있다.


1. DB와 캐시를 알림 시스템 주 서버에서 분리한다.
2. 알림 서버 scale-out을 시도한다.
3. 메시지 큐를 이용해 시스템 컴포넌트 사이에 강한 결합을 끊는다.


![extended_arch](/chapter-10/img/extended_arch.png)


- 1부터 N까지의 서비스: 알림 시스템 서버의 API를 사용해 알림을 보낼 서비스들
- 알림 서버가 수행하는 기능들
    - 알림 전송 API 제공: 스팸 방지나 보안 등을 위해 사내 서비스 or 인증된 클라이언트만 이용가능
    - 알림 검증: 이메일 주소, 전화번호 등에 대한 기본적인 검증 수행
    - DB or 캐시에 질의: 알림에 포함시킬 데이터가 있다면 가져온다
    - 알림 전송: 알림 데이터를 발행해 MQ에 넣는다. 필요에 따라 큐를 확장하여 알림을 병렬적으로 처리할 수 있다.
- 메시지 큐
    - 시스템 컴포넌트 간 의존성 제거를 위해 사용
    - 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할 수행
    - 본 설계에서는 알림 종류 별로 별도의 메시지 큐를 사용하고 있는데, third-party 중에 하나에 장애가 발생해도 다른 종류의 알림은 정상 동작한다.
- 작업 서버: 메시지 큐에서 알림 이벤트를 꺼내 third-party로 보냄


## 3. 상세 설계
- 이전에 대략적 설계에서 추가로 짚어야 하는 부분이 있다. (안정성 및 추가 컴포넌트 고려)


### 안정성
- 알림 데이터 손실 방지를 위한 알림 로그 DB
    - 알림이 지연되거나 순서가 달라도 괜찮지만, 사라지면 안된다는 것을 가정.
- 알림 중복 전송 방지
    - 알림의 Event ID 등을 검사하여 중복 이벤트는 버리도록 설정


### 추가 컴포넌트 고려
- 알림 템플릿 사용
    - 전송될 알림들의 형식을 일관성있게 유지하고, 오류 가능성이나 알림 작성에 소모되는 시간을 줄인다.
- 알림 설정 세분화
    - 사용자가 알림에 피곤함을 느끼지 않도록 특정 종류, 수신 여부 등을 사용자가 설정할 수 있도록 하고, 이를 DB에 저장하여 체크해야한다.
- 전송률 제한
    - 한 사용자가 받을 수 있는 알림의 빈도를 제한하여 사용자가 피곤하지 않으면서도 적절한 알림을 받을 수 있도록 만든다.
- 실패 시 재시도 로직
    - third-party 에서 알림 전송에 실패할 시, 해당 알림을 재시도 전용 큐에 넣고 관리할 수 있다.
    - 실패 원인을 분류하고 재시도 횟수, backoff 전략을 설정할 수 있다.
- Push 알림과 보안
    - iOS와 안드로이드 앱의 경우, 알림 전송 API를 사용할 때 고유 `appKey`와 `appSecret`을 사용하여 보안을 유지한다.
    - 인증된 클라이언트만 해당 API를 사용할 수 있기 때문에 모바일 알림을 구현할 때 고려해야 한다.
- 큐 모니터링
    - 큐에 쌓이는 이벤트 개수나 처리 속도를 모니터링한다.
    - 너무 많은 알림 이벤트들이 쌓여 빠르게 처리되고 있지 않다면, 작업 서버(Consumer) 확장을 고려한다.
- 이벤트 추적
    - 알림 수신 여부, 클릭률, 전환률 등 비즈니스적으로 중요한 메트릭을 추적하여 데이터 분석 플랫폼으로 이관할 수 있다.


위 모든 조건들을 고려하여 만든 최종 설계안은 아래와 같다.


![final](/chapter-10/img/final.png)


## 4. Summary
- 위 설계는 규모 확장이 쉬울 뿐만 아니라 Push, SMS, Email 등 다양한 정보 전달 방식을 사용하는 알림 시스템이다.
- 시스템 컴포넌트 사이의 결합도를 낮추기 위해서 메시지 큐를 적극적으로 사용할 수 있다.


설계 시 집중해야 할 키워드는 다음과 같다.


1. 안정성: 메시지 전송 실패율을 낮추기 위한 안정적인 재시도 메커니즘 도입
2. 보안: 인증된 클라이언트만이 알림을 보낼 수 있도록 `appKey`, `appSecret` 등의 메커니즘 활용
3. 이벤트 추적 및 모니터링: 알림 생성 후 전송까지 과정 추적 및 모니터링 툴, 시스템 통합 필요
4. 사용자 설정 체크: 사용자가 알림 수신 여부나, 알림 종류 등을 설정했다면 이를 시스템 설계에서도 체크하도록 반영하기
5. 전송률 제한: 사용자에게 알림을 보내는 빈도를 제한할 수 있도록 하여 불편함 방지